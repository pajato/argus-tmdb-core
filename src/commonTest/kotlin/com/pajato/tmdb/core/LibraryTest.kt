/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.pajato.tmdb.core

import kotlin.reflect.KClass
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue
import kotlin.test.fail

class LibraryTest {
    private fun testTmdbData(name: String) {
        val nonHomogenousCollection = "The $name collection contains inconsistent typed data!"
        val list = listOf(createDefaultFromType(name))
        assertTrue(list.size == 1 && list[0] !is TmdbError, "Detected an error in the $name default creation.")
        assertTrue(list.isNotEmpty(), "Incorrect number of $name!")
        when (name) {
            "Collection" -> assertTrue(list[0] is Collection, nonHomogenousCollection)
            "Keyword" -> assertTrue(list[0] is Keyword, nonHomogenousCollection)
            "Movie" -> assertTrue(list[0] is Movie, nonHomogenousCollection)
            "Network" -> assertTrue(list[0] is Network, nonHomogenousCollection)
            "Person" -> assertTrue(list[0] is Person, nonHomogenousCollection)
            "ProductionCompany" -> assertTrue(list[0] is ProductionCompany, nonHomogenousCollection)
            "TvSeries" -> assertTrue(list[0] is TvSeries, nonHomogenousCollection)
            else -> fail("Unsupported type: $name.")
        }
    }

    private fun testEmptyTmdbDataItem(item: TmdbData) {
        assertTrue(item is TmdbError, "A non-blank input did not generate an error!")
    }

    @Test
    fun `when the TMDB network data is accessed the count is greater than 0`() {
        testTmdbData("Network")
    }

    @Test fun `when the TMDB movie data is accessed the count is greater than 0`() {
        testTmdbData("Movie")
    }

    @Test fun `when the TMDB tv series data is accessed the count is greater than 0`() {
        testTmdbData("TvSeries")
    }

    @Test fun `when the TMDB person data is accessed the count is greater than 0`() {
        testTmdbData("Person")
    }

    @Test fun `when the TMDB production company data is accessed the count is greater than 0`() {
        testTmdbData("ProductionCompany")
    }

    @Test fun `when the TMDB collections data is accessed the count is greater than 0`() {
        testTmdbData("Collection")
    }

    @Test fun `when the TMDB keywords data is accessed the count is greater than 0`() {
        testTmdbData("Keyword")
    }

    @Test fun `when creating a collection with an invalid list name verify that an error is generated`() {
        val list = listOf(createDefaultFromType("fred"))
        assertTrue(list.size == 1 && list[0] is TmdbError, "Did not detect an error for the list name `fred` with default creation.")
    }

    @Test fun `when creating a collection with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Collection.create(""))
    }

    @Test fun `when creating a keyword with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Keyword.create(""))
    }

    @Test fun `when creating a movie with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Movie.create(""))
    }

    @Test fun `when creating a network with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Network.create(""))
    }

    @Test fun `when creating a person with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Person.create(""))
    }

    @Test fun `when creating a production company with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(ProductionCompany.create(""))
    }

    @Test fun `when creating a tv series with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(TvSeries.create(""))
    }

    @Test fun `when an error item is passed created verify it matches the default`() {
        val errorItem = TmdbError("A default error item.")
        assertEquals(errorItem, createFromJson("{}", errorItem), "Invalid error item creation!")
    }

    @Test fun `when an invalid list name is parsed verify an error result`() {
        val result = parse("", "")
        assertTrue(result is TmdbError, "Parsing error detection failed!")
    }

    @Test fun `exercise the parser for each TmdbData subclass`() {
        fun <T : TmdbData> testParse(type: KClass<T>, json: String) {
            val listName = type.getListName()
            val actual = json.toTmdbData(listName)
            val errorMessage = "Wrong type computed!"
            when (listName) {
                Collection.listName -> assertTrue(actual is Collection, errorMessage)
                Keyword.listName -> assertTrue(actual is Keyword, errorMessage)
                Movie.listName -> assertTrue(actual is Movie, errorMessage)
                Person.listName -> assertTrue(actual is Person, errorMessage)
                ProductionCompany.listName -> assertTrue(actual is ProductionCompany, errorMessage)
                Network.listName -> assertTrue(actual is Network, errorMessage)
                TvSeries.listName -> assertTrue(actual is TvSeries, errorMessage)
                else -> fail("Invalid list name!")
            }
        }

        testParse(Collection::class, """{"id":645,"name":"James Bond Collection"}""")
        testParse(Keyword::class, """{"id":730,"name":"factory worker"}""")
        testParse(Movie::class, """{"adult":true,"id":6,"original_title":"Maix","popularity":3.1,"video":true}""")
        testParse(Person::class, """{"adult":false,"id":658,"name":"Alfred Molina","popularity":4.154}""")
        testParse(ProductionCompany::class, """{"id":601,"name":"Blake Edwards Entertainment"}""")
        testParse(Network::class, """{"id":601,"name":"ABC News"}""")
        testParse(TvSeries::class, """{"id":602,"original_name":"Love on a Rooftop","popularity":1.133}""")
    }

    @Test fun `when each TmdbData subclass is used to obtain a list name verify that it is correct`() {
        TmdbData::class.sealedSubclasses.forEach {
            val uut = it.getListName()
            val errorMessage = "Wrong list!"
            when (it) {
                Collection::class -> assertEquals(Collection.listName, uut, errorMessage)
                Keyword::class -> assertEquals(Keyword.listName, uut, errorMessage)
                Movie::class -> assertEquals(Movie.listName, uut, errorMessage)
                Network::class -> assertEquals(Network.listName, uut, errorMessage)
                Person::class -> assertEquals(Person.listName, uut, errorMessage)
                ProductionCompany::class -> assertEquals(ProductionCompany.listName, uut, errorMessage)
                TvSeries::class -> assertEquals(TvSeries.listName, uut, errorMessage)
                TmdbError::class -> assertTrue(true)
            }
        }
    }

    @Test fun `when invalid JSON data is parsed verify that a TmdbError is generated`() {
        val notJson = "j;lakfjal;al;fja;ljf;a;jal;jal;kj;a"
        val uut = notJson.parse(Movie.serializer())
        assertTrue(uut is TmdbError, "Bad JSON was parsed without error!")
        assertEquals(notJson, uut.message, "Invalid text after parse!")
    }
}
