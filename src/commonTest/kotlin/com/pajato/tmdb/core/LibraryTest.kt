/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.pajato.tmdb.core

import kotlin.test.*

class LibraryTest {
    private fun testTmdbData(name: String) {
        val nonHomogenousCollection = "The $name collection contains inconsistent typed data!"
        val list = listOf(createDefaultFromType(name))
        assertTrue(list.size == 1 && list[0] !is TmdbError, "Detected an error in the $name default creation.")
        assertTrue(list.isNotEmpty(), "Incorrect number of $name!")
        when (name) {
            "Collection" -> assertTrue(list[0] is Collection, nonHomogenousCollection)
            "Keyword" -> assertTrue(list[0] is Keyword, nonHomogenousCollection)
            "Movie" -> assertTrue(list[0] is Movie, nonHomogenousCollection)
            "Network" -> assertTrue(list[0] is Network, nonHomogenousCollection)
            "Person" -> assertTrue(list[0] is Person, nonHomogenousCollection)
            "ProductionCompany" -> assertTrue(list[0] is ProductionCompany, nonHomogenousCollection)
            "TvSeries" -> assertTrue(list[0] is TvSeries, nonHomogenousCollection)
            else -> fail("Unsupported type: $name.")
        }
    }

    private fun testEmptyTmdbDataItem(item: TmdbData) {
        assertTrue(item is TmdbError, "A non-blank input did not generate an error!")
    }

    @Test fun `when the TMDB network data is accessed the count is greater than 0`() {
        testTmdbData("Network")
    }

    @Test fun `when the TMDB movie data is accessed the count is greater than 0`() {
        testTmdbData("Movie")
    }

    @Test fun `when the TMDB tv series data is accessed the count is greater than 0`() {
        testTmdbData("TvSeries")
    }

    @Test fun `when the TMDB person data is accessed the count is greater than 0`() {
        testTmdbData("Person")
    }

    @Test fun `when the TMDB production company data is accessed the count is greater than 0`() {
        testTmdbData("ProductionCompany")
    }

    @Test fun `when the TMDB collections data is accessed the count is greater than 0`() {
        testTmdbData("Collection")
    }

    @Test fun `when the TMDB keywords data is accessed the count is greater than 0`() {
        testTmdbData("Keyword")
    }

    @Test fun `when creating a collection with an invalid list name verify that an error is generated`() {
        val list = listOf(createDefaultFromType("fred"))
        assertTrue(list.size == 1 && list[0] is TmdbError, "Did not detect an error for the list name `fred` with default creation.")
    }

    @Test fun `when creating a collection with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Collection.create(""))
    }

    @Test fun `when creating a keyword with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Keyword.create(""))
    }

    @Test fun `when creating a movie with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Movie.create(""))
    }

    @Test fun `when creating a network with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Network.create(""))
    }

    @Test fun `when creating a person with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(Person.create(""))
    }

    @Test fun `when creating a production company with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(ProductionCompany.create(""))
    }

    @Test fun `when creating a tv series with a blank JSON argument that an error is signalled`() {
        testEmptyTmdbDataItem(TvSeries.create(""))
    }

    @Test fun `when an error item is passed created verify it matches the default`() {
        val errorItem = TmdbError("A default error item.")
        assertEquals(errorItem, createFromJson("{}", errorItem), "Invalid error item creation!")
    }

    @Test fun `when an invalid list name is parsed verify an error result`() {
        val result = parse("", "")
        assertTrue(result is TmdbError, "Parsing error detection failed!")
    }

    @Test fun `exercise the parser for each TmdbData subclass`() {
        parse(Collection.listName, """{"id":645,"name":"James Bond Collection"}""")
        parse(Keyword.listName, """{"id":730,"name":"factory worker"}""")
        parse(Movie.listName, """{"adult":false,"id":603,"original_title":"The Matrix","popularity":32.156,"video":false}""")
        parse(Person.listName, """{"adult":false,"id":658,"name":"Alfred Molina","popularity":4.154}""")
        parse(ProductionCompany.listName, """{"id":601,"name":"Blake Edwards Entertainment"}""")
        parse(Network.listName, """{"id":601,"name":"ABC News"}""")
        parse(TvSeries.listName, """{"id":602,"original_name":"Love on a Rooftop","popularity":1.133}""")
    }

    @Test fun `when a page object is created verify the properties`() {
        val type = Collection::class
        val pageSize = 25
        val list = mutableListOf<Collection>()
        val uut = Page(type, pageSize, list)
        assertEquals(type, uut.type, "Wrong type!")
        assertEquals(pageSize, uut.pageSize, "Wrong page size!")
        assertEquals(list, uut.list, "Wrong list!")
    }

    @Test fun `when a page list has an error verify hasError and getError generate correct results`() {
        val errorMessage = "some error message"
        val uut = Page(Movie::class, 25, mutableListOf(TmdbError(errorMessage)))
        assertTrue(uut.hasError(), "No error is indicated!")
        assertEquals(errorMessage, uut.getError(), "Wrong error message!")
    }

    @Test fun `when a page list has no error verify hasError and getError generate correct results`() {
        val uut = Page(Network::class, 25, mutableListOf(Network()))
        assertFalse(uut.hasError(), "An error is indicated!")
        assertEquals("", uut.getError(), "Wrong error message!")
    }
}
